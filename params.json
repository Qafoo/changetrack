{"name":"Changetrack","tagline":"Track changes through the history of PHP projects","body":"ChangeTrack\r\n===========\r\n\r\n[![image](https://travis-ci.org/Qafoo/changetrack.png)](https://travis-ci.org/Qafoo/changetrack)\r\n\r\n[![image](https://scrutinizer-ci.com/g/Qafoo/changetrack/badges/quality-score.png?s=15cd5a7c521b0e59db4c537ff8525381039cf013)](https://scrutinizer-ci.com/g/Qafoo/changetrack/)\r\n\r\nThe Qafoo ChangeTrack tool allows you to track changes in classes and\r\nmethods throughout the history of a PHP project. One application for\r\nthis analysis is to detect artifacts that are changed most frequently\r\nand especially most frequently due to bugs.\r\n\r\nThe analysis is performed in multiples steps. Currently supported are:\r\n\r\n1.  Analyze which classes/methods are affected by a revision.\r\n2.  Analyze which classes/methods are most frequently affected by\r\n    changes.\r\n\r\nThe split into multiple steps allows you to\r\n\r\na)  Cache the result of a step to apply multiple other analysis steps on\r\n    top.\r\nb)  Easily apply analysis processes which are currently not supported by\r\n    ChangeTrack.\r\n\r\nThe different analysis types are combined in the single `track` shell\r\ncommand. Executing it using:\r\n\r\n    $ src/bin/track\r\n\r\nWill provide you with a list of sub-commands to perform actual analysis.\r\n\r\nInstallation\r\n------------\r\n\r\nTo install the tool obtain a copy from Github, get\r\n[Composer](http://getcomposer.org/doc/00-intro.md) and execute:\r\n\r\n    $ composer install\r\n\r\nAfter that, you can use ChangeTrack from `src/bin/track`.\r\n\r\nCommands\r\n--------\r\n\r\nIn following, the currently implemented analysis commands are described\r\nin further detail.\r\n\r\n### analyze\r\n\r\nThe `analyze` command tracks changes of a PHP project throughout its\r\nversion history (currently only Git is supported). The result is an XML\r\ndocument, that describes the version history in terms of class/method\r\nchanges. For example, here is a part of the\r\n[Twig](https://github.com/fabpot/Twig) project history:\r\n\r\n    <changes repository=\"https://github.com/fabpot/Twig\">\r\n      <!-- ... -->\r\n      <changeSet revision=\"92bbc7ee405f5635f4647040d883dbd77d1ac7da\" message=\"made a small optimization to for loop when no else clause exists&#10;git-svn-id: http://svn.twig-project.org/trunk@32 93ef8e89-cb99-4229-a87c-7fa0fa45744b&#10;\">\r\n        <package name=\"\">\r\n          <class name=\"Twig_Node_For\">\r\n            <method name=\"compile\">\r\n              <added>15</added>\r\n              <removed>3</removed>\r\n            </method>\r\n          </class>\r\n        </package>\r\n      </changeSet>\r\n      <!-- ... -->\r\n    </changes>\r\n\r\nEach revision (which contains a change to a class/method) is reflected\r\nin a `<changeSet />` which gives you the version (hash) and the commit\r\nmessage. Contained is information about all method changes (structured\r\nby package and class name) and statistics on the number of added/removed\r\nlines.\r\n\r\nYou can restrict the history to be analyzed by a start and end commit\r\nthrough command line parameters. This makes some sense, since analysis\r\nis quite expensive: Every revision needs to be checked out and static\r\nanalysis is performed to detect which artifacts are affected by the\r\nchange.\r\n\r\nThe raw output of the `analyze` command is not really useful, yet. You\r\nshould apply the `calculate` command to it.\r\n\r\n### calculate\r\n\r\nThe `calculate` analyzes, how often an artifact (i.e. method) is\r\naffected by what kind of change (e.g. *bug* or *feature*). To do so, it\r\nattempts to assign a *label* to each commit in the project history and\r\ncounts per method, how often a specifically labeled commit touched it.\r\nTo do this, the `calculate` command operates on the output of the\r\n`analyze` command (either by specifying the input file as an argument on\r\nthe shell or by just piping it from STDIN).\r\n\r\nIn order to find a label for a commit, `calculate` commonly analyzes the\r\ncommit message for keywords (e.g. \"implemented\" or \"fixed\"), but can\r\nalso utilize other methods (e.g. checking for a Github issue reference\r\nand looking up its assigned labels through the Github API). The label\r\nfor a commit is then assigned to each artifact that was changed in that\r\ncommit.\r\n\r\nSince every project has a different style of crafting its commit\r\nmessages, you can define how labels are determined through a dedicated\r\n`config.yml` file (`-c` option), for example. The default configuration\r\n(chosen if now `-c` option is present) looks like this:\r\n\r\n    revision_label_provider:\r\n        chain:\r\n            - regex:\r\n                pattern: '(fixed)i'\r\n                label:   'fix'\r\n            - regex:\r\n                pattern: '(implemented)i'\r\n                label:   'implement'\r\n            - default:\r\n                label:   'misc'\r\n\r\nThis specific `config.yml` defines a chain of label providers. For a\r\ncommit, each of the defined label providers (2 x `regex`, 1 x `default`)\r\nis asked to provide a label. If a provider can provide a label, this one\r\nis chosen.\r\n\r\nThe `regex` label provider tries to match `pattern` against the commit\r\nmessage and returns the defined `label` if it found a match. The\r\n`default` provider always returns the defined `label` and therefore\r\nfinishes the chain.\r\n\r\nAn example output gathered using the default regex configuration (from\r\nabove) for the [Twig](https://github.com/fabpot/Twig) repository is\r\nshown below:\r\n\r\n    <stats  repository=\"https://github.com/fabpot/Twig\">\r\n      <package name=\"\">\r\n        <!-- ... -->\r\n        <class name=\"Twig_Environment\">\r\n          <!-- ... -->\r\n          <method name=\"loadTemplate\">\r\n            <stats>\r\n              <count label=\"misc\">17</count>\r\n              <count label=\"fix\">1</count>\r\n            </stats>\r\n          </method>\r\n        </class>\r\n      </package>\r\n    </stats>\r\n\r\nAs you can see, each method that occurrs in the history is listed\r\ntogether with the number of changes with a specific label. So, the\r\n`calculate` command found *17* commits with the label *misc* and *1*\r\ncommit with the label *fix* for the method\r\n`Twig_Environment::loadTemplate()`.\r\n\r\nBesides the *regex* and *default* label providers, there's a *Github\r\nissue* label provider available, which uses your projects issue labels\r\nto determine a change label. An example configuration for\r\n[vfsStream](https://github.com/mikey179/vfsStream) project looks like\r\nthis:\r\n\r\n    revision_label_provider:\r\n        chain:\r\n            - github:\r\n                issue_url_template: https://api.github.com/repos/mikey179/vfsStream/issues/:id/labels?access_token=<github_oauth_token>\r\n                label_map:\r\n                    bug:        bug\r\n                    feature:    feature\r\n            - regex:\r\n                pattern: '(implemented)i'\r\n                label:   'feature'\r\n            - regex:\r\n                pattern: '(fix)i'\r\n                label:   'bug'\r\n            - regex:\r\n                pattern: '(merged)i'\r\n                label:   'merge'\r\n            - default:\r\n                label:   'misc'\r\n\r\nThe first provider in the chain tries to extract a Github issue\r\nreference (e.g. `#23`) from the commit message. If that is available,\r\nthe Github API is used to determine labels for that issue. The labels\r\nprovded by Github are then mapped to local labels (which are the same\r\nhere).\r\n\r\nIf that provider does not find a label, 3 regexes are tried after each\r\nother. Finally, if none of the previous providers found a label, the\r\ndefault provider sets the *misc* label.\r\n\r\nRoadmap\r\n-------\r\n\r\nThe ChangeTrack tool is currently in a very early alpha state. It has\r\nonly been run against a couple of repositories and it is expected that\r\nyou find quite some bugs. However, here are some of the features which\r\nwould make sense in the future:\r\n\r\n-   Support different version control systems (e.g. SVN)\r\n-   Performance improvements\r\n-   Further label providers (e.g. by Jira issue labels)\r\n-   Additional analysis, e.g. frequent item sets to determine coupling\r\n\r\nPlease add your ideas for additional features to the Github issue\r\ntracker and possibly provide a pull request.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}